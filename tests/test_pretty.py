import pytest

from mkdocs_typer2.pretty import (
    Argument,
    CommandEntry,
    CommandNode,
    Option,
    parse_markdown_to_tree,
    tree_to_markdown,
)


def test_parse_markdown_basic_command():
    markdown = """
# mycli
A test CLI tool

```console
$ mycli --help
```

**Arguments**:
* `name`: The name argument [required]

**Options**:
* `--verbose`: Enable verbose mode
* `--output`: Output file path [required]
"""

    result = parse_markdown_to_tree(markdown)

    assert result.name == "mycli"
    assert len(result.arguments) == 1
    assert result.arguments[0].name == "name"
    assert result.arguments[0].required

    assert len(result.options) == 2
    assert result.options[0].name == "--verbose"
    assert not result.options[0].required
    assert result.options[1].name == "--output"
    assert result.options[1].required


def test_tree_to_markdown_basic():
    cmd = CommandNode(
        name="mycli",
        description="A test CLI",
        usage="mycli --help",
        arguments=[Argument(name="input", description="Input file", required=True)],
        options=[
            Option(name="--verbose", description="Verbose output", required=False),
            Option(name="--format", description="Output format", default="json"),
        ],
    )

    markdown = tree_to_markdown(cmd)

    assert "# mycli" in markdown
    assert "A test CLI" in markdown
    assert "`mycli --help`" in markdown
    assert "`input`" in markdown
    assert "`--verbose`" in markdown
    assert "`--format`" in markdown
    assert "`json`" in markdown


def test_tree_to_markdown_with_subcommands():
    cmd = CommandNode(
        name="mycli",
        description="Root command",
        subcommands=[
            CommandNode(
                name="init",
                description="Initialize project",
                options=[Option(name="--force", description="Force init")],
            )
        ],
    )

    markdown = tree_to_markdown(cmd)

    assert "# mycli" in markdown
    assert "### init" in markdown
    assert "Initialize project" in markdown
    assert "`--force`" in markdown


def test_empty_tables():
    cmd = CommandNode(name="mycli", description="A test CLI")

    markdown = tree_to_markdown(cmd)

    assert "*No arguments available*" in markdown
    assert "*No options available*" in markdown


def test_option_with_default():
    markdown = """
# mycli

**Options**:
* `--style`: Output style default: no-caps
"""

    result = parse_markdown_to_tree(markdown)

    assert len(result.options) == 1
    assert result.options[0].name == "--style"
    assert result.options[0].default == "no-caps"


@pytest.mark.parametrize(
    "usage_text",
    [
        "```console\n$ mycli run\n```",
        "```console\n$ mycli run --help\n```",
    ],
)
def test_parse_usage_section(usage_text):
    markdown = f"""
# mycli

{usage_text}
"""
    result = parse_markdown_to_tree(markdown)
    assert result.usage is not None
    assert result.usage.startswith("mycli")


def test_parse_markdown_with_descriptions():
    """Test that descriptions are properly parsed from the markdown."""
    markdown = """
# mycli

A test CLI tool with description

## `command`

Command description spans
multiple lines with details

```console
$ mycli command
```

**Arguments**:
* `name`: The name argument [required]

**Options**:
* `--verbose`: Enable verbose mode
"""
    tree = parse_markdown_to_tree(markdown)

    # Check root command description
    assert tree.name == "mycli"
    assert "A test CLI tool with description" in tree.description

    # Check subcommand description
    assert len(tree.subcommands) == 1
    subcommand = tree.subcommands[0]
    assert subcommand.name == " `command`"
    assert "Command description spans" in subcommand.description
    assert "multiple lines with details" in subcommand.description


def test_parse_typer_generated_docs():
    """Test parsing the actual format generated by the Typer CLI tool."""
    markdown = """
# `typer`

A sample CLI

**Usage**:

```console
$ typer [OPTIONS] COMMAND [ARGS]...
```

**Options**:

* `--install-completion`: Install completion for the current shell.
* `--show-completion`: Show completion for the current shell, to copy it or customize the installation.
* `--help`: Show this message and exit.

**Commands**:

* `docs`: Generate docs for a project
* `hello`: Some docstring content

## `typer docs`

Generate docs for a project

**Usage**:

```console
$ typer docs [OPTIONS]
```

**Options**:

* `--name TEXT`: The name of the project  [required]
* `--help`: Show this message and exit.

## `typer hello`

Some docstring content

**Usage**:

```console
$ typer hello [OPTIONS] NAME
```

**Arguments**:

* `NAME`: The name of the person to greet  [required]

**Options**:

* `--caps / --no-caps`: Whether to capitalize the name  [default: no-caps]
* `--color TEXT`: The color of the output
* `--help`: Show this message and exit.
"""
    tree = parse_markdown_to_tree(markdown)

    # Check root command
    assert tree.name == "typer"
    assert "A sample CLI" in tree.description

    # Check subcommands
    assert len(tree.subcommands) == 2

    # Check docs subcommand
    docs_cmd = next(cmd for cmd in tree.subcommands if "typer docs" in cmd.name)
    assert "Generate docs for a project" in docs_cmd.description
    assert docs_cmd.usage == "typer docs [OPTIONS]"
    assert len(docs_cmd.options) > 0
    assert any(opt.name == "--name TEXT" for opt in docs_cmd.options)

    # Check hello subcommand
    hello_cmd = next(cmd for cmd in tree.subcommands if "typer hello" in cmd.name)
    assert "Some docstring content" in hello_cmd.description
    assert hello_cmd.usage == "typer hello [OPTIONS] NAME"
    assert len(hello_cmd.arguments) > 0
    assert len(hello_cmd.options) > 0
    assert any(arg.name == "NAME" for arg in hello_cmd.arguments)
    assert any(opt.name == "--caps / --no-caps" for opt in hello_cmd.options)


def test_parse_markdown_with_commands():
    markdown = """
# mycli

**Commands**:
* `foo`: Foo command description
* `bar`: Bar command description
"""
    result = parse_markdown_to_tree(markdown)
    assert len(result.commands) == 2
    assert result.commands[0].name == "foo"
    assert result.commands[0].description == "Foo command description"
    assert result.commands[1].name == "bar"
    assert result.commands[1].description == "Bar command description"


def test_tree_to_markdown_with_commands():
    cmd = CommandNode(
        name="mycli",
        description="A test CLI",
        commands=[
            CommandEntry(name="foo", description="Foo command description"),
            CommandEntry(name="bar", description="Bar command description"),
        ],
    )
    markdown = tree_to_markdown(cmd)
    assert "| Name | Description |" in markdown
    assert "`foo`" in markdown and "Foo command description" in markdown
    assert "`bar`" in markdown and "Bar command description" in markdown


def test_tree_to_markdown_no_commands():
    """Test that commands table shows 'No commands available' when empty."""
    cmd = CommandNode(name="test", commands=[])
    result = tree_to_markdown(cmd)
    assert "*No commands available*" in result


def test_parse_markdown_with_line_breaks():
    """Test that line breaks in help text are preserved."""
    markdown = """# mycli

A test CLI tool

This is a multi-line help message.

```console
$ mycli --help
```

**Arguments**:
* `name`: The name argument [required]

**Options**:
* `--verbose`: Enable verbose mode
"""
    tree = parse_markdown_to_tree(markdown)

    # Check that line breaks are preserved in the description
    assert tree.name == "mycli"
    assert "A test CLI tool" in tree.description
    assert "This is a multi-line help message." in tree.description
    # Verify there's a line break between the two lines
    assert "\n" in tree.description
    assert tree.description.count("\n") >= 1
